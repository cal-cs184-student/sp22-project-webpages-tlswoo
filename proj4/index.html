<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=ODelI1aHBYDBqgeIAH2zlJpCfVcp84aqLawScqpMaD_6HccaI_esRRCiUg1W99dz');ol{margin:0;padding:0}table td,table th{padding:0}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Source Sans Pro";font-style:normal}.c3{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Source Sans Pro";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Source Sans Pro";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:center}.c7{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c5{page-break-after:avoid}.c6{text-indent:36pt}.c2{height:12pt}.c8{font-size:16pt}.title{padding-top:0pt;color:#000000;font-weight:700;font-size:26pt;padding-bottom:3pt;font-family:"Source Sans Pro";line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:center}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:12pt;font-family:"Source Sans Pro"}p{margin:0;color:#000000;font-size:12pt;font-family:"Source Sans Pro"}h1{padding-top:0pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:0pt;font-family:"Source Sans Pro";line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Source Sans Pro";line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Source Sans Pro";line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Source Sans Pro";line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Source Sans Pro";line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Source Sans Pro";line-height:1.5;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c7"><p class="c4"><span class="c9">CS 184 Assignment 4: Clothsim</span></p><p class="c4"><span class="c8">Brandon Shin</span></p><p class="c4 c2"><span class="c0"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 369.33px;"><img alt="" src="images/image16.png" style="width: 624.00px; height: 369.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><h1 class="c1 c5" id="h.9zt1owwbhb28"><span class="c3">Part 1: Masses and Springs</span></h1><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To represent a cloth, I started by evenly placing point masses at even intervals around the cloth&rsquo;s area. The number of masses and their spacing was determined by the num_width_points and num_height_points values, as well as the cloth&rsquo;s width and height. The position of these masses was dependent on the cloth&rsquo;s orientation: horizontal cloths would have fixed y-values at 1.0, and the x and z-values would be spread evenly, while vertical cloths would have randomly varying z-values between &plusmn;0.001, and evenly-spread x and y-values.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 524.00px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 524.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Once the masses were initialized, I created the springs using pointer arithmetic. For the following descriptions, I will refer to the &ldquo;current&rdquo; point mass&rsquo;s pointer as *pm. Structural constraints exist between the left and upper masses, which are found with *pm - 1 and *pm - width, respectively. Shearing constraints exist between the diagonal upper left and right masses, which are found with *pm - width - 1 and *pm - width + 1. Finally, bending constraints exist between the left and upper masses that are two masses away; thus, building off of the structural constraint expressions, we have *pm - 2 and *pm - (width * 2).</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Below are some screenshots of pinned2.json, with various constraints toggled on/off:</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 523.69px;"><img alt="" src="images/image13.png" style="width: 624.00px; height: 523.69px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 523.69px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 523.69px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 523.69px;"><img alt="" src="images/image12.png" style="width: 624.00px; height: 523.69px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><h1 class="c1 c5" id="h.byh4wimib02s"><span class="c3">Part 2: Simulation via Numerical Integration</span></h1><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compute the forces acting on each point mass, I began by iterating over the external_accelerations vector, and calculated the force per acceleration by multiplying it by the </span><span>cloth&rsquo;s</span><span class="c0">&nbsp;mass; this value was stored in a force vector, that was then applied uniformly to every point mass in the system. Next, I applied the spring constraint forces to each point mass to simulate the physical properties of cloth. This value was calculated using Hooke&rsquo;s law, and for my implementation I used a negative value for the spring constant. The resulting inverted force value represents the force pushing from the &ldquo;center&rdquo; of the spring, to either end, so all I had to do was multiply the unit vector pointing to each respective side by this constant to apply the spring force in the correct direction.</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After the forces were calculated, I used Verlet integration to estimate each point mass&rsquo;s new position after one timestep. The damping value and delta t value are provided, and the current/previous positions of each point mass are stored in every PointMass instance. To find the acceleration, we just take the net forces and divide by the total mass of the cloth, and we can just plug all the values in to get the point mass&rsquo;s new position. Finally, to avoid excess spring deformation, we check all of the springs in the cloth; if the distance between any two points of a spring is longer than 10% of the resting spring length, we clamp the value to that same maximum value. This positional correction was performed using a similar method of multiplying the unit vectors pointing toward either end of the spring, by the difference between the current and max spring lengths, and then adding that to the position of either/both masses.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 523.69px;"><img alt="" src="images/image20.png" style="width: 624.00px; height: 523.69px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I did some experimentation below with a few of the parameters, and here are my findings:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 368.00px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 368.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For the spring constant, a lower value made the cloth retain its shape far less, and have more wrinkles; this is because the springs do not exert very much force at all in either direction, so the weight of the cloth easily deforms the springs. With a very high spring constant value, the cloth becomes almost rigid, and there are only wrinkles along the edge created by the pinned corners of the cloth. The overall shape of the cloth is very much retained, and almost perfectly squared off.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 367.94px;"><img alt="" src="images/image18.png" style="width: 624.00px; height: 367.94px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For the density, there is an almost inverse relationship with the varying spring constant values. With a very low cloth density, the cloth becomes very smooth and easily retains its shape; this is because the forces exerted on the springs are very low, which allows the springs to easily retain their constraints. With a very high cloth density, the force being applied to each spring is much greater, and the cloth becomes greatly deformed compared to the low density cloth; the wrinkles created in this cloth are very similar to the wrinkles created by the low spring constant cloth, though there are some subtle differences.</span></p><p class="c1 c6"><span>Finally, when varying the damping value, there weren&rsquo;t any </span><span>screenshottable</span><span class="c0">&nbsp;differences, since the damping value changed the speed at which the cloth fell, as well as the perceived smoothness of said movement. With a very low damping value, the cloth fell very quickly into its final position, and with a high damping value, the cloth seemed to fall in slow motion. In our Verlet integration equation, the expression (1 - damping_value) is used to scale the difference in previous/current positions; thus, with a high damping value, the difference in positions is made much smaller than if we had used a low damping value.</span></p><hr style="page-break-before:always;display:none;"><p class="c1 c6 c2"><span class="c0"></span></p><h1 class="c1 c5" id="h.dvnd491llyvs"><span class="c3">Part 3: Handling Collisions with Other Objects</span></h1><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To implement collision with spheres, I followed the steps laid out by the project spec. First, I got the vector from the origin of the sphere, to the current point mass. If the magnitude of that vector was less than or equal to the sphere&rsquo;s radius, then a collision was present. In such cases, I calculated the difference between the radius of the sphere and the origin vector, and added this value (scaled by the friction) to the point mass&rsquo;s current position, to move it to the surface of the sphere.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 446.50px; height: 519.49px;"><img alt="" src="images/image1.png" style="width: 446.50px; height: 519.49px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 344.95px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 344.95px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Above are some simulations performed with different spring constant values. With a lower spring constant value, the cloth looks more &ldquo;droopy&rdquo; and hangs further below the sphere. The shape of the sphere is much more defined and visible at the top of the image. With a higher spring constant value, the cloth&rsquo;s original shape is more retained, and there are far fewer wrinkles. You can see more kinks in the cloth around each wrinkle, caused by the cloth&rsquo;s increased rigidity.</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To implement collision with planes, I began by determining whether the point mass&rsquo;s last position was &ldquo;above&rdquo; (on the side the plane&rsquo;s normal vector was pointing) or &ldquo;below&rdquo; (the other side) the plane; in the former case, the correction vector&rsquo;s direction would be in the normal vector&rsquo;s direction, and in the latter case, the opposite of the normal&rsquo;s direction. To calculate the tangent point of the point mass to the plane, I took the vector from the plane&rsquo;s defined point to the point mass&rsquo;s last position, and projected it onto the normal/inverse normal vector, depending on which side the point mass&rsquo;s last position was on. Inverting this vector, and adding it to the last_position value of the point mass, gave me the tangent point. Finally, I added the correction vector scaled by the friction to this tangent point (whose direction was determined earlier) to correctly update the point mass&rsquo;s current position. A small offset value is added so that the cloth rests very slightly above the plane&rsquo;s surface.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 428.92px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 428.92px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h1 class="c1 c5" id="h.59ropfkx4bv7"><span class="c3">Part 4: Handling Self-Collisions</span></h1><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To handle self-collisions, I first implemented hashing of point mass position values in order to speed up which point masses to check against each other. I followed the spec here, and calculated w, h, and t values the same way. I used fmod() with the x, y, and z positions of the point mass, and with the w, h, and t values, and used floor() to get a final float value. Using this hashing function, I populated a spatial map consisting of subsets of point masses that were relationally close to one another. Finally, I implemented self-collision checking by checking a point mass against all other point masses in the same spatial subset; for any point masses that were too close, I created a composite correctional vector to update the position of our current point mass, and averaged/applied this vector to the point mass after processing the entire subset.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 297.53px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 297.53px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4 c2"><span class="c0"></span></p><p class="c1"><span class="c0">I performed some additional testing by varying the density/spring constant parameters, and my findings are as follows:</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 365.79px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 365.79px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">While falling, the cloth with the low spring constant had way more smaller wrinkles in it, and deformed much more while falling/starting to collide with itself. On the other hand, the cloth with the very high spring constant was overall very smooth, and could be seen retaining part of its shape and smoothness as it fell onto itself; notice how the folds in the cloth are far fewer and far smoother than those of the low spring constant cloth.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 365.79px;"><img alt="" src="images/image17.png" style="width: 624.00px; height: 365.79px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">Again, it seems that the results of low/high spring constant values and low/high densities are almost inverses of each other. The low density cloth fell far slower, almost like a piece of paper; the cloth did not weigh so heavily on itself as it deformed, and retained most of its shape (similar to the cloth with a high spring constant). However, there are larger gaps between the folds of cloth. On the other hand, the high density cloth falls faster, and compresses on itself far more than the low density cloth. The folds are much more flattened out and slightly more deformed, but overall the resting position looks more natural.</span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h1 class="c1 c5" id="h.ofikxhsv2p6n"><span class="c3">Part 5: Shaders</span></h1><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shader programs are GPU-based programs that can be run in parallel to the main graphics pipeline. This allows for the possibility of having realtime graphics rendering, which is useful in interactive settings such as simulations or video games. Vertex shaders are shaders that perform transformations on vertices themselves, modifying geometric attributes and the vertex&rsquo;s final position. Fragment shaders handle values dealing with OpenGL &ldquo;fragments,&rdquo; which for the purpose of this project we can think of as pixels. They take in the transformed values from the vertex shader, and perform any necessary calculations to get the final color value for any given pixel. Vertex and fragment shaders work hand in hand, as the vertices will first get processed by the vertex shader, and the final vertex locations will be passed on and processed by the fragment shader.</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blinn-Phong shading allows us to show specularly-reflected light in our scene. We do this by scaling the intensity of the light depending on how close/far we are to the mirror direction of the light.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 541.50px; height: 603.65px;"><img alt="" src="images/image21.png" style="width: 541.50px; height: 603.65px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c6"><span class="c0">The mirror direction is the light vector, reflected across the normal at the point of contact with some surface; if the view direction is close to this vector, then we will see a brighter specular reflection. This is achieved by taking the bisector of the view vector and the light vector, and dotting it with the normal vector; higher values mean that our view vector is very close to the mirror direction, and lower values mean we are farther from the mirror direction. This value is scaled by some exponent p; for higher values of p, the specular reflection is much sharper and has a smaller radius, and for lower values of p the reflection is more spread out.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 285.85px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 285.85px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4 c2"><span class="c0"></span></p><p class="c1 c6"><span class="c0">Implementing texture mapping was straightforward, as I was able to use the built-in texture sampling function texture(). All I had to do was pass in the texture stored as a sampler2D and the uv coordinate of the current vertex to get the corresponding color value.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 476.94px; height: 531.50px;"><img alt="" src="images/image19.png" style="width: 476.94px; height: 531.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For bump mapping, I began by creating the tangent-bitangent-normal (TBN) matrix detailed in the project spec. Then, I calculated values for dU and dV using the helper function h() to sample from the R-channel of the provided texture. Using these values, I was able to create the local space normal vector, and transform it to model space using the TBN matrix from above. I used my shader code for Blinn-Phong shading here, and replaced the normal used in those calculations with the displacement vector, to get a bump-mapped final result.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 365.79px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 365.79px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For displacement mapping, I used the same fragment shader from bump mapping, and modified the displacement vertex shader. Given the input position and normals, I calculated the new position for the current vertex by scaling its model-space normal vector by the value from our h() function, and the height scaling variable provided, and adding it to its initial position. Not only are the colors dependent on the normals of the vertices at every position, but the vertices themselves are also transformed to reflect these changes.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 365.79px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 365.79px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When comparing the two shading methods, for this particular application I prefer the bump mapping technique. The overall shape and form of the sphere and cloth are left alone, and we still get the benefits of added detail from the use of our displacement vector that is factored in during shading calculations. The displaced vertices look somewhat unnatural, and don&rsquo;t quite fit the current situation. We are dealing with a very primitive sphere object and a physics-bound cloth, and the texture I chose was that of a brick wall, which definitely puts displacement mapping at somewhat of a disadvantage; in a more complex scene with, say, a brick wall, the added detail and realism from displacement shading would be much better appreciated.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When comparing different mesh coarseness values for the sphere, there was hardly any noticeable difference for bump mapping. However, with displacement mapping, there was a very noticeable difference:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 365.79px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 365.79px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">At a lower mesh coarseness, there are far fewer vertices on the mesh, and thus the individual vertices that are modified are distinctly visible. With a higher mesh coarseness, since there are so many more vertices, the displacement happens at a much finer level of detail. The resulting sphere has far more jagged edges caused by way more displaced vertices. I experimented with a far lower height scaling coefficient with a higher mesh coarseness, and the resulting sphere realistically portrayed the detail in the brick wall without looking as jagged.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementing mirror mapping was relatively straightforward. We start with the outgoing &ldquo;eye vector,&rdquo; which is the vector traveling from the camera&rsquo;s position to the fragment. We reflect this vector across the surface normal of that fragment, to get the mirrored direction of the eye vector. Finally, we sample the cubemap representing our skybox/environment in the direction of the mirror vector, to get the mirrored pixel.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 379.42px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 379.42px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c4 c2"><span class="c0"></span></p></body></html>